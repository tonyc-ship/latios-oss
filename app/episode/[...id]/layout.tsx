import type { Metadata } from 'next';
import { headers } from 'next/headers';
import { getTranslations } from '@/lib/i18n/server';
import { supabase } from '@/lib/supabase';

export async function generateMetadata(
  { params }: { params: Promise<{ id?: string[] }> }
): Promise<Metadata> {
  const { id: rawId } = await params;
  const idParams = (rawId as string[]) || [];
  const [podcastIdParam, episodeIdParam, typeParam] = idParams;
  const episodeId = episodeIdParam || podcastIdParam || '';
  const platform = typeParam || 'apple';

  let title = 'Episode Summary | Latios';
  let description = 'Podcast episode summary generated by Latios.';
  let podcastId: string | undefined;
  let ogImage: string | undefined;
  let podcastName: string | undefined;
  let episodeTitle: string | undefined;
  let episode: any = undefined;

  try {
    if (episodeId) {
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string | undefined;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string | undefined;
      if (supabaseUrl && supabaseAnonKey) {
        const url = `${supabaseUrl}/rest/v1/tbl_episode?select=guid,title,podcast_name,podcast_id,description,itunes_summary,itunes_subtitle,itunes_image,itunes_duration,pub_date&guid=eq.${encodeURIComponent(episodeId)}`;
        const res = await fetch(url, {
          headers: {
            apikey: supabaseAnonKey,
            Authorization: `Bearer ${supabaseAnonKey}`,
            Accept: 'application/json',
          },
          cache: 'no-store',
        });
        if (res.ok) {
          const rows = await res.json();
          episode = Array.isArray(rows) ? rows[0] : rows;
          if (episode) {
            podcastId = episode.podcast_id?.toString();
            podcastName = episode.podcast_name || '';
            episodeTitle = episode.title || '';
            const baseTitle = episode.title || '';
            const showPart = episode.podcast_name ? ` | ${episode.podcast_name}` : '';
            title = `${baseTitle} — Summary & Key Takeaways${showPart} | Latios`;
            const desc = episode.description || episode.itunes_summary || episode.itunes_subtitle || '';
            const addon = ' Read the AI-generated summary, key takeaways, and highlights.';
            description = ((desc || `${baseTitle}${showPart} — AI summary and highlights.`) + addon).slice(0, 300);
            ogImage = episode.itunes_image || undefined;
          }
        }
      }
    }
  } catch {}

  // Always build canonical from params when present to avoid falling back to root
  const url = (podcastIdParam && episodeIdParam)
    ? `https://www.latios.ai/episode/${podcastIdParam}/${episodeIdParam}/${platform}`
    : `https://www.latios.ai/episode`;

  return {
    title,
    description,
    keywords: [
      'podcast summary','AI summary','transcript', 'highlights',
      podcastName || '', episodeTitle || ''
    ].filter(Boolean),
    alternates: { canonical: url, languages: { en: url, zh: url } },
    robots: { index: true, follow: true },
    // Add explicit meta tags to ensure Google reads them correctly
    other: {
      'article:author': 'Latios',
      'article:section': 'Podcast Summary',
      'article:tag': [episodeTitle || '', podcastName || ''].filter(Boolean).join(', '),
      'article:published_time': episode?.pub_date || '',
      'article:modified_time': episode?.update_time || '',
    },
    openGraph: {
      title,
      description,
      url,
      siteName: 'Latios',
      type: 'article',
      images: ogImage ? [{ url: ogImage }] : undefined,
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: ogImage ? [ogImage] : undefined,
      creator: '@latios_ai',
    },
  };
}

export default async function EpisodeLayout({
  children,
  params,
}: {
  children: React.ReactNode;
  params: Promise<{ id?: string[] }>
}) {
  // Build PodcastEpisode / VideoObject JSON-LD server-side
  let jsonLd: any = null;
  let breadcrumbJsonLd: any = null;
  let prevLink: { href: string; label: string } | null = null;
  let nextLink: { href: string; label: string } | null = null;
  let prevText: string = 'Previous';
  let nextText: string = 'Next';
  try {
    const { id: rawId } = await params;
    const idParams = (rawId as string[]) || [];
    const [podcastIdParam, episodeIdParam, typeParam] = idParams;
    const episodeId = episodeIdParam || podcastIdParam || '';
    const platform = typeParam || 'apple';
    const h = await headers();
    const acceptLang = h.get('accept-language') || '';
    const locale = (h.get('x-locale') || (acceptLang.startsWith('zh') ? 'zh' : 'en')) as string;
    try {
      const { t } = await getTranslations(locale, 'common');
      prevText = t('episode.previousEpisode');
      nextText = t('episode.nextEpisode');
    } catch {}

    if (episodeId) {
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string | undefined;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string | undefined;
      if (supabaseUrl && supabaseAnonKey) {
        const url = `${supabaseUrl}/rest/v1/tbl_episode?select=guid,title,podcast_name,podcast_id,description,itunes_summary,itunes_subtitle,itunes_image,itunes_duration,pub_date&guid=eq.${encodeURIComponent(episodeId)}`;
        const res = await fetch(url, {
          headers: { apikey: supabaseAnonKey, Authorization: `Bearer ${supabaseAnonKey}` },
          cache: 'no-store',
        });
        const rows = res.ok ? await res.json() : [];
        const episode = Array.isArray(rows) ? rows[0] : rows;
        if (episode) {
          const baseUrl = 'https://www.latios.ai';
          const pageUrl = (podcastIdParam && episodeIdParam)
            ? `${baseUrl}/episode/${podcastIdParam}/${episodeIdParam}/${platform}`
            : `${baseUrl}/episode`;
          const name = episode?.title || 'Episode';
          const showName = episode?.podcast_name || undefined;
          const description = (episode?.description || episode?.itunes_summary || episode?.itunes_subtitle || '').slice(0, 500) || undefined;
          const image = episode?.itunes_image || undefined;
          const datePublished = episode?.pub_date || undefined;
          const duration = episode?.itunes_duration ? `PT${String(episode.itunes_duration).toUpperCase()}` : undefined;

          if (platform === 'youtube') {
            // Minimal VideoObject for YouTube page
            jsonLd = {
              '@context': 'https://schema.org',
              '@type': 'VideoObject',
              name,
              description,
              thumbnailUrl: image ? [image] : undefined,
              uploadDate: datePublished,
              duration,
              url: pageUrl,
              isFamilyFriendly: true,
            };
          } else {
            // Enhanced PodcastEpisode for Apple/XYZ style pages with more structured data
            jsonLd = {
              '@context': 'https://schema.org',
              '@type': 'PodcastEpisode',
              name,
              description,
              url: pageUrl,
              image,
              datePublished,
              duration,
              partOfSeries: showName ? { '@type': 'PodcastSeries', name: showName } : undefined,
              isAccessibleForFree: true,
              // Add more specific properties for better SEO
              headline: `${name} — Summary & Key Takeaways`,
              abstract: description,
              about: {
                '@type': 'Thing',
                name: showName || 'Podcast Episode'
              },
              publisher: {
                '@type': 'Organization',
                name: 'Latios',
                url: 'https://www.latios.ai'
              },
              mainEntityOfPage: {
                '@type': 'WebPage',
                '@id': pageUrl
              }
            };
          }
        }
      }
    }
    
    
    
    // Build breadcrumb JSON-LD if we have identifiers
    try {
      const baseUrl = 'https://www.latios.ai';
      if (podcastIdParam && episodeIdParam) {
        const pageUrl = `${baseUrl}/episode/${podcastIdParam}/${episodeIdParam}/${platform}`;
        breadcrumbJsonLd = {
          '@context': 'https://schema.org',
          '@type': 'BreadcrumbList',
          itemListElement: [
            { '@type': 'ListItem', position: 1, name: 'Home', item: baseUrl },
            { '@type': 'ListItem', position: 2, name: 'Podcast', item: `${baseUrl}/podcast/${podcastIdParam}?type=${platform}` },
            { '@type': 'ListItem', position: 3, name: 'Episode', item: pageUrl },
          ],
        };
      }
    } catch {}
    

    // Build Prev/Next links (by pub_date within same podcast)
    try {
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL as string | undefined;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY as string | undefined;
      if (supabaseUrl && supabaseAnonKey && podcastIdParam && episodeId) {
        // Get current episode metadata
        const currentUrl = `${supabaseUrl}/rest/v1/tbl_episode?select=guid,podcast_id,title,pub_date,update_time&guid=eq.${encodeURIComponent(episodeId)}`;
        const currentRes = await fetch(currentUrl, {
          headers: { apikey: supabaseAnonKey, Authorization: `Bearer ${supabaseAnonKey}` },
          cache: 'no-store',
        });
        const currentRows = currentRes.ok ? await currentRes.json() : [];
        const current = Array.isArray(currentRows) ? currentRows[0] : currentRows;
        const currentDate = current?.pub_date || current?.update_time;

        if (currentDate) {
          // Previous (earlier than currentDate): order desc to get immediate previous
          const prevUrl = `${supabaseUrl}/rest/v1/tbl_episode?select=guid,title,pub_date&podcast_id=eq.${encodeURIComponent(podcastIdParam)}&pub_date=lt.${encodeURIComponent(currentDate)}&order=pub_date.desc&limit=1`;
          const prevRes = await fetch(prevUrl, { headers: { apikey: supabaseAnonKey, Authorization: `Bearer ${supabaseAnonKey}` }, cache: 'no-store' });
          const prevRows = prevRes.ok ? await prevRes.json() : [];
          const prev = Array.isArray(prevRows) ? prevRows[0] : null;
          if (prev?.guid) {
            prevLink = { href: `/episode/${podcastIdParam}/${prev.guid}/${platform}` , label: `${prev.title || prev.guid}` };
          }

          // Next (later than currentDate): order asc to get immediate next
          const nextUrl = `${supabaseUrl}/rest/v1/tbl_episode?select=guid,title,pub_date&podcast_id=eq.${encodeURIComponent(podcastIdParam)}&pub_date=gt.${encodeURIComponent(currentDate)}&order=pub_date.asc&limit=1`;
          const nextRes = await fetch(nextUrl, { headers: { apikey: supabaseAnonKey, Authorization: `Bearer ${supabaseAnonKey}` }, cache: 'no-store' });
          const nextRows = nextRes.ok ? await nextRes.json() : [];
          const next = Array.isArray(nextRows) ? nextRows[0] : null;
          if (next?.guid) {
            nextLink = { href: `/episode/${podcastIdParam}/${next.guid}/${platform}` , label: `${next.title || next.guid}` };
          }
        }
      }
    } catch {}
  } catch {}

  return (
    <div className="min-h-screen">
      <div className="container mx-auto px-4">
          {children}
          {(prevLink || nextLink) ? (
            <nav aria-label="Episode navigation" className="mt-8" data-nosnippet>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                <div className="sm:justify-self-start">
                  {prevLink ? (
                    <a
                      href={prevLink.href}
                      className="group inline-flex items-center gap-2 rounded-lg border border-gray-200 bg-white px-3 py-2 text-sm text-gray-700 shadow-sm hover:border-gray-300 hover:shadow transition-colors"
                    >
                      <svg className="h-4 w-4 text-gray-400 group-hover:text-gray-600" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fillRule="evenodd" d="M12.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 1.414L8.414 10l4.293 4.293a1 1 0 010 1.414z" clipRule="evenodd" />
                      </svg>
                      <span className="text-gray-500">{prevText}</span>
                      <span className="truncate max-w-[12rem]">{prevLink.label}</span>
                    </a>
                  ) : <span></span>}
                </div>
                <div className="sm:justify-self-end">
                  {nextLink ? (
                    <a
                      href={nextLink.href}
                      className="group inline-flex items-center gap-2 rounded-lg border border-gray-200 bg-white px-3 py-2 text-sm text-gray-700 shadow-sm hover:border-gray-300 hover:shadow transition-colors"
                    >
                      <span className="text-gray-500">{nextText}</span>
                      <span className="truncate max-w-[12rem]">{nextLink.label}</span>
                      <svg className="h-4 w-4 text-gray-400 group-hover:text-gray-600" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fillRule="evenodd" d="M7.293 4.293a1 1 0 011.414 0l5 5a1 1 0 010 1.414l-5 5a1 1 0 11-1.414-1.414L11.586 10 7.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                      </svg>
                    </a>
                  ) : <span></span>}
                </div>
              </div>
            </nav>
          ) : null}
      </div>
      {jsonLd ? (
        <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }} />
      ) : null}
      {breadcrumbJsonLd ? (
        <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: JSON.stringify(breadcrumbJsonLd) }} />
      ) : null}
    </div>
  );
}